<!DOCTYPE html>
<html lang="en">

<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title></title>
<link rel="icon" type="image/x-icon" href="https://imgur.com/KHsmkJk.png">

<meta property="og:title" content="https://neyrox.lol" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://neyrox.lol" />
<meta property="og:image" content="https://imgur.com/KHsmkJk.png" />
<meta property="og:description" content="personal private biosite" />
<meta name="theme-color" content="#FFFFFF">
<style>


  body {
    color: white;
    display: flex;
    align-items: center;
    overflow: hidden; /* Hide scrollbars */
    justify-content: center;
    height: 100vh; /* Viewport height */
    margin: 0;
  }

  .video-background {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    z-index: -1; /* Place video behind other content */
  }

  .darken {
    filter: brightness(50%);
  }

  .blur {
    filter: blur(10px);
  }

  .sepia {
    filter: sepia(100%);
  }

  .grayscale {
    filter: grayscale(100%);
  }

  .invert {
    filter: invert(100%);
  }

  .saturate {
    filter: saturate(200%);
  }

  .hue-rotate {
    filter: hue-rotate(90deg);
  }

  html {
    cursor: ew-resize;
  }
 
  .myCanvas {
    position:absolute;
    top: 0;
    left: 0;
    transform:translateX(50%,50%);
    border: 1px solid black;
    background-color: transparent;
}

#weatherAnimation {
        height: 100vh;
        position: relative;
        z-index: 10;
}
  #container {
	/* Center the text in the viewport. */
	position: absolute;
	margin: auto;
	width: 100vw;
	height: 80px;
	top: 0;
	bottom: 0;
	
	/* This filter is a lot of the magic, try commenting it out to see how the morphing works! */
	filter: url(#threshold) blur(0.6px);
}

.tooltip-container {
  position: relative;
  display: inline-block;
}

.tooltip-container .tooltip-text {
  visibility: hidden;
  width: auto; /* Ajuste la largeur en fonction du contenu */
  max-width: 200px; /* Optionnel : limite la largeur du tooltip */
  background-color: black;
  color: #fff;
  text-align: center;
  border-radius: 10px;
  padding: 8px 12px; /* Ajuste le padding pour le confort visuel */
  position: absolute;
  z-index: 1;
  bottom: 125%; /* Positionne au-dessus de l'élément */
  left: 50%;
  transform: translateX(-50%); /* Centre le tooltip horizontalement */
              font-family: 'Sintony', sans-serif;
  opacity: 0;
  transition: opacity 0.5s ease-in-out, visibility 0s ease-in-out 0.5s; /* Effet de fondu lors de l'apparition et de la disparition */
  white-space: nowrap; /* Empêche le texte de se casser sur plusieurs lignes */
}

.tooltip-container:hover .tooltip-text {
  visibility: visible;
  opacity: 1;
  font-family: 'Sintony', sans-serif;
  transition: opacity 0.5s ease-in-out; /* Effet de fondu lors de l'apparition */
}

.fa-crown:hover {
  background: linear-gradient(to right, #ffffff 50%, #ffff00  5% );
            background-size: auto auto;
            background-clip: border-box;
            background-size: 200% auto;
            color: #fff;
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: textclip 1.5s linear infinite;
    }

  .snowflake {
    position: fixed;
    top: -10%;
    z-index: 9999;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    cursor: default;
    -webkit-animation-name: snowflakes-fall, snowflakes-shake;
    -webkit-animation-duration: 10s, 3s;
    -webkit-animation-timing-function: linear, ease-in-out;
    -webkit-animation-iteration-count: infinite, infinite;
    -webkit-animation-play-state: running, running;
    animation-name: snowflakes-fall, snowflakes-shake;
    animation-duration: 10s, 3s;
    animation-timing-function: linear, ease-in-out;
    animation-iteration-count: infinite, infinite;
    animation-play-state: running, running;
}
.snowflake:nth-of-type(0) {
    left: 1%;
    -webkit-animation-delay: 0s, 0s;
    animation-delay: 0s, 0s;
}


/* Start https://www.cursors-4u.com */ * {cursor: url(https://cur.cursors-4u.net/symbols/sym-7/sym637.ani), url(https://cur.cursors-4u.net/symbols/sym-7/sym637.png), auto !important;} /* End https://www.cursors-4u.com */

.snowflake:nth-of-type(1) {
    left: 10%;
    -webkit-animation-delay: 1s, 1s;
    animation-delay: 1s, 1s;
}

.snowflake:nth-of-type(2) {
    left: 20%;
    -webkit-animation-delay: 6s, .5s;
    animation-delay: 6s, .5s;
}

.snowflake:nth-of-type(3) {
    left: 30%;
    -webkit-animation-delay: 4s, 2s;
    animation-delay: 4s, 2s;
}

.snowflake:nth-of-type(4) {
    left: 40%;
    -webkit-animation-delay: 2s, 2s;
    animation-delay: 2s, 2s;
}

.snowflake:nth-of-type(5) {
    left: 50%;
    -webkit-animation-delay: 8s, 3s;
    animation-delay: 8s, 3s;
}

.snowflake:nth-of-type(6) {
    left: 60%;
    -webkit-animation-delay: 6s, 2s;
    animation-delay: 6s, 2s;
}

.snowflake:nth-of-type(7) {
    left: 70%;
    -webkit-animation-delay: 2.5s, 1s;
    animation-delay: 2.5s, 1s;
}

.snowflake:nth-of-type(8) {
    left: 80%;
    -webkit-animation-delay: 1s, 0s;
    animation-delay: 1s, 0s;
}

.snowflake:nth-of-type(9) {
    left: 90%;
    -webkit-animation-delay: 3s, 1.5s;
    animation-delay: 3s, 1.5s;
}

.crosshair {cursor: crosshair;}

canvas {
  width: 100%;
  height: 100%;
  position: absolute;
  left: 0;
  top: 0;
  background: #0a0a0a;
}

.fog {
  width: 100%;
  height: 70px;
  position: absolute;
  left: 0;
  top: 0;
  backdrop-filter: blur(20px);
}

  .overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgb(12, 12, 17);
    
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2; /* High z-index to ensure it's above other elements */
  }
  .hidden {
  opacity:0;
}
.console-container {
 
  font-family: 'Libre Franklin', sans-serif;
  font-size:15px;
  display:block;
  color:white;

}
.console-underscore {
   display:inline-block;

}

  .wrapper {
            text-align: center;
        }

        .wrapper h1 {
            color: #fff;
            font-size: 34px;
            font-weight: 700;
            font-family: "Josefin Sans", sans-serif;
            background: linear-gradient(to right, #a9a0ac 10%, #ffffff 50%);
            background-size: auto auto;
            background-clip: border-box;
            background-size: 200% auto;
            color: #fff;
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: textclip 1.5s linear infinite;
            display: inline-block;
        }

        @keyframes textclip {
            to {
                background-position: 200% center;
            }
        }

        .crown-icon {
            font-size: 24px; /* Adjust the icon size as needed */
        }

        .click-text {
    color: white;
    font-size: 2em;
    animation: glow 0.5s ease-in-out infinite alternate;
    font-family: 'Sintony', sans-serif;
  }


  .description-text {
    color:white;
    font-family: 'Noto Sans Mono', monospace;
  }

  .icon {
      font-size: 24px;
      color: white;
      transition: color 0.2s ease-in-out;
    }

    .icon:hover {
      color: #FFD700;
    }

  
  #text1, #text2 {
	position: absolute;
	width: 100%;
	display: inline-block;
	color:white;

  font-family: 'Sintony', monospace;
	
	font-size: 25pt;
	
	text-align: center;
	
	user-select: none;
}

.line, .ip-display, .website-link, #secret-ip {
            font-family: 'Sintony', sans-serif;
        }

        /* Sparkles effect */
        @keyframes sparkles {
            0% { text-shadow: 0 0 5px rgba(255, 255, 255, 0.5), 0 0 10px rgba(255, 255, 255, 0.5), 0 0 15px rgba(255, 255, 255, 0.5); }
            50% { text-shadow: 0 0 10px rgba(255, 255, 255, 1), 0 0 20px rgba(255, 255, 255, 1), 0 0 30px rgba(255, 255, 255, 1); }
            100% { text-shadow: 0 0 5px rgba(255, 255, 255, 0.5), 0 0 10px rgba(255, 255, 255, 0.5), 0 0 15px rgba(255, 255, 255, 0.5); }
        }

        .sparkles {
            animation: sparkles 1s infinite;
        }

        #secret-ip {
            position: relative;
            display: inline-block;
            overflow: hidden; /* Ensure the text does not overflow the container */
        }

        #ipv4, #ipv6 {
            transition: opacity 0.5s ease-in-out; /* Smooth transition for opacity changes */
        }

        #ipv6 {
            opacity: 0; /* Initially hidden */
        }

        #secret-ip.hover #ipv4 {
            opacity: 0; /* Hide IPv4 on hover */
        }

        #secret-ip.hover #ipv6 {
            opacity: 1; /* Show IPv6 on hover */
        }

  .fade-out {
    animation: fadeOut 1s forwards;
  }
  
  .profile-container {
    text-align: center;
    position: relative;
    background-color:rgba(0, 0, 0, 0.5);
    padding: 20px;
    border-radius: 15px; /* Rounded corners */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.6); /* Shadow effect */
    max-width: 340px; /* Maximum width */
    width: 100%;
    border: solid;
    border-color:#313030;
    border: 1px solid rgb(255, 255, 255);
  }
    

        

  
  .profile-picture {
    width: 150px;
    height: 150px;
    border-radius: 50%;
    border: 3px solid #ffffff;
    display: block;
    margin: 20px auto;
  }
  .profile-info {
    margin: 10px;
  }
  .social-icons {
    list-style: none;
    padding: 0;
  }
  .social-icons li {
    display: inline;
    margin: 0 10px;
  }
  .social-icons li a {
    color: white;
    text-decoration: none; /* Remove underline from links */
  }
  .social-icons li a:hover {
    text-decoration: underline; /* Adds an underline on hover */
  }
  .ip-display {
    margin-top: 20px;
  }
  .website-link {
    position: absolute;
    bottom: -30px; /* Adjust as needed */
    left: 50%;
    transform: translateX(-50%);
    width: auto;
  }
  .line {
      display: block;
      width: 100px;
      height: 2px;
      background-color: #fff;
      margin-top: 8px;
      margin-left: auto;
      margin-right: auto;
    }
   

    .custom-cursor {
  cursor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='64' height='64' viewBox='0 0 64 64'%3E%3Ctitle%3Ecursor-link%3C/title%3E%3Cg%3E%3Ccircle cx='32' cy='32' r='30' opacity='.8'%3E%3C/circle%3E%3Cpath d='M30.828 28.172l-.585-.586a2 2 0 0 1 0-2.828l6.171-6.171a2 2 0 0 1 2.828 0l6.171 6.171a2 2 0 0 1 0 2.828l-6.171 6.171a2 2 0 0 1-2.828 0l-.586-.585' fill='none' stroke='%23fff' stroke-linecap='round' stroke-linejoin='round' stroke-width='2'%3E%3C/path%3E%3Cpath d='M33.172 35.828l.585.586a2 2 0 0 1 0 2.828l-6.171 6.171a2 2 0 0 1-2.828 0l-6.171-6.171a2 2 0 0 1 0-2.828l6.171-6.171a2 2 0 0 1 2.828 0l.586.585' fill='none' stroke='%23fff' stroke-linecap='round' stroke-linejoin='round' stroke-width='2'%3E%3C/path%3E%3Cpath fill='none' stroke='%23fff' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M27 37l10-10'%3E%3C/path%3E%3C/g%3E%3C/svg%3E") 32 32, pointer;

  /* 👇 PNG fallback */
  cursor: -webkit-image-set(url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAACXBIWXMAAAsSAAALEgHS3X78AAAFGUlEQVR4nO1bS0gcSRj+KwbDLhMRI1kciQQWnFMuu7koHgLi0YsefCCCHuaoCHsQD74O4kEUPc5BD4qPg148quBBEDTJdRkhEAwzQ4LKYIaESKSWv6nqLXu6p19V3TOZ+WBw1O6/6/v7+x9VXU0opVDOeFTW7AHgseoLEEKaAeA1AODPKAD8ZXPKewBIA8AFALyllF4oHZ+KECCEvAEA/on4NJcDgGP8UEqPJQ1RhzQHEEKeAkAfAHQCQIMUo/nIAMA+AGxRSr/KMCjFAYSQOAD0S7jbToGq2KSUJnyP3Y8DCCF/A8C0wjtuB1TENKX0nVcDnhzA5B5nki8GbAFAwktYuHYAIQQz+QLL6sUErBb/UErTyhzASloiwFh3C8wNcTel03EjVALkgY0twcbqCI4cUCLkOVw5wTYEWMxvlgh5ERgO/XY5oaACWLZfKEHywMa8wDhYwi4E4kWY7d2gmXGwhKUDWJNTLHXeD/oYF1NY5gBCyH6IHZ5sZCilnWY2TRXAevvAydfX11ctLi5GU6nUq7Ozs+aRkZFnkkw3ME55yFMASxr7QSc+JH9ychKLxWK/iX/f29u77u7u/ijhElgVOo3tspkC+sIkn0wmv7e2tv47NTX1Cf/X1dX1bHd396WEy0TMcpqZAgKNfSP5tra25NXV1T3+D0NgeXlZIy9JCXm54IEC2EpOUZBHrKysXI+OjmqkJSmhgXHUYQyBN/nnqIEdeYVOCN8BTslzSHaCuQPY5CGQ5Le9vf3SKXkOoxN8lMiIOFESFfDao0FXiMVi1e3t7bW5XO7eKXkOdAKvDgMDA356BJ2r6IBAev66ujrtWcTt7e29kTyGxuHh4Z+rq6svrM4/ODjAeg6NjY1PfAzDVAFRHwYd4/T09Fs6nb6LRqPVk5OTz/l5PC+gOpqamqrN7OExa2trWvzv7Oxc+xiGzlV0gN0TG89A2be0tPzOzx8fH9dkXFtb+xhMkmJvb29evTceMzc399nHkHSueiNECHkrmzgOGhMe3lX8He88kl9fX8+Kx9hVBLdVwwkopVoeUOYAcdCY8DDmUfbsWu/CJA+CA5Q8HLUaNMa8leyDJC9CugL8EMOpcDab/Tk7O/tFNXklIeD3rlJKtZUbzBU1NTVVkUikStWd5w6QtkFChqQHBwc/8BKJ5I+OjrIqyIuQogC/sh8bG2tA8rw6YMm8ubn5mUwm76QxNcBMAe+9GpuYmPjDLlat+n+Mefw5Pz+vd3/YLKkkL3IVHeDqoaKInp4erS8fGhr6aCXXy8vLOzNJY8LjshebJcXQuYpl0PNenFQq9QMJdHR0RPDumR0zPDz8yezvGBqY8PA7yj4gB+hcRQV4zgEbGxtaXz4zM/PCzTSV5wWe8BTLXoTO9cGaICHk2OuaAC5S4Dwdv+O8HaeuhY4PosmxQI5Sqi+KGMug511YuGCJC5f4HRcyCykhRPJg5CjNAeDQCSGTh4IOYPvwMn6sF3JCEZDPGPcamnWC+36vYnQCToKwxIVMHsy4KX00JiZGjhDJO3s0xg7YlHFFVAJWhPPz86/Y7CwtLWVCIg9sY2XeNrrK4/ECJ02rG0/gsORi6QC2/XTrFyC/VWgrrd16QMLPHKEIcME4WKKyTc7OCjMQZwZLBXzLrO0U39GSGNt7WypOcLVf2PGaYIk4Qd1mafjfCf1FmhgvWMy7GlvlhYnKKzOVl6Yqr83JsPPQaDm+OGl5gXJ8dbaUUN5vjwPAfz2vBz0d3cIRAAAAAElFTkSuQmCC") 1x, url("data:image/png;base64,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") 2x) 32 32, pointer;
}

.fa-discord:hover {
  background: linear-gradient(to right, #ffffff 50%, #7b777c  5% );
            background-size: auto auto;
            background-clip: border-box;
            background-size: 200% auto;
            color: #fff;
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: textclip 1.5s linear infinite;
    }

    .fa-steam:hover {
      background: linear-gradient(to right, #ffffff 50%, #7b777c  5% );
            background-size: auto auto;
            background-clip: border-box;
            background-size: 200% auto;
            color: #fff;
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: textclip 1.5s linear infinite;
    }

    .fa-heart:hover {
      background: linear-gradient(to right, #ffffff 50%, #7b777c  5% );
            background-size: auto auto;
            background-clip: border-box;
            background-size: 200% auto;
            color: #fff;
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: textclip 1s linear infinite;
    }

    .fa-folder:hover {
      background: linear-gradient(to right, #ffffff 50%, #7b777c  5% );
            background-size: auto auto;
            background-clip: border-box;
            background-size: 200% auto;
            color: #fff;
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: textclip 1s linear infinite;
    }
    
    .fa-code:hover {
      background: linear-gradient(to right, #ffffff 50%, #7b777c 5% );
            background-size: auto auto;
            background-clip: border-box;
            background-size: 200% auto;
            color: #fff;
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: textclip 1.5s linear infinite;
    }


.toggles {
  position: absolute;
  z-index: 100;
  left: 20px;
  bottom: 20px;
  color: #aaaaaa;
  display: none;
}
  @keyframes glow {
    from {
      text-shadow: 0 0 10px white, 0 0 20px white, 0 0 30px white;
    }
    to {
      text-shadow: 0 0 20px white, 0 0 30px white, 0 0 40px white;
    }
  }

  @keyframes fadeOut {
    to {
      opacity: 0;
      visibility: hidden;
    }
  }



  @-webkit-keyframes snowflakes-fall {
    0% { top: -10% }
    100% { top: 100% }
}

@-webkit-keyframes snowflakes-shake {
    0% { -webkit-transform: translateX(0px); transform: translateX(0px) }
    50% { -webkit-transform: translateX(80px); transform: translateX(80px) }
    100% { -webkit-transform: translateX(0px); transform: translateX(0px) }
}

@keyframes snowflakes-fall {
    0% { top: -10% }
    100% { top: 100% }
}

@keyframes snowflakes-shake {
    0% { transform: translateX(0px) }
    50% { transform: translateX(80px) }
    100% { transform: translateX(0px) }
}

@import url(https://fonts.googleapis.com/css?family=Khula:700);
</style>
</head> 

<body>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha384-..." crossorigin="anonymous">
<div class="profile-container">
  <div id="overlay" class="overlay">

        <span id="text1"></span>
        <span id="text2"></span>
    </div>

  
    <div class="tooltip-container">
      <i class="fas fa-crown"></i>
      <span class="tooltip-text">Owner</span>
    </div>
    <img src="pfp2.gif" alt="Profile Picture" class="profile-picture">
    <div class="profile-info">
      <div class="wrapper">
        <h1 style="margin-left: 25px;">NeyRox</h1> <img src="https://cdn3.emoji.gg/emojis/8509-star.png" style="width: 25px; height: 25px; margin-left: 10px;">
    </div>
  
  <div class='console-container'><span id='text'></span><div class='console-underscore' id='console'>&#95;</div></div>

  </div>
  <ul class="social-icons">
    <!-- Replace # with the actual links -->
    
  <li><a href="https://discord.com/users/566572805349572608" target="_blank"><i class="fab fa-discord"></i></a></li>
  <li><a href="https://steamcommunity.com/id/neyrox236" target="_blank"><i class="fab fa-steam"></i></a></li>
  <li><a href="https://github.com/NeyRoxWZ" target="_blank"><i class="fa-solid fa-code"></i></a></li>
  <li><a href="https://neyrox.lol" target="_blank"><i class="fa-solid fa-heart"></i></a></li>
  <li><a href="lennyportefolio.systeme.io" target="_blank"><i class="fa-solid fa-folder"></i></i></i></a></li>
  </ul>
  
<!-- Ajoutez l'une des classes "darken", "blur", "sepia", "grayscale", "invert", "saturate" ou "hue-rotate" pour appliquer un effet -->
    <video class="video-background blur" autoplay loop muted>
    <source src="music.mp4" type="video/mp4">
    Your browser does not support the video tag.
  </video>
 

  <div class="line"></div>
  <div class="ip-display sintony">
      https://neyrox.lol/ Soon <span id="user-ip"></span> 
  </div>
  <div class="website-link"></div>
  <div id="secret-ip" class="hidden sintony">
      <span id="your-ip-text">Your IP:</span> <span id="ipv4"></span>
      <span id="ipv6"></span>
  </div>




<!-- fonts -->

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Sintony:wght@700&display=swap" rel="stylesheet">


<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Mono&display=swap" rel="stylesheet">

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Libre+Franklin:wght@300&display=swap" rel="stylesheet">




<audio id="background-music" src="music.mp3" preload="auto" loop></audio>

<script>
  // JavaScript to handle the click event on the overlay
  const overlay = document.getElementById('overlay');
  overlay.addEventListener('click', function() {
    // Play the music
    const audio = document.getElementById('background-music');
    audio.play();
    
    // Add the fade-out class to trigger the fade-out animation
    this.classList.add('fade-out');
    
    // Remove the overlay from the DOM after the animation ends
    setTimeout(() => {
      overlay.remove();
    }, 1000); // Corresponds to the animation duration
  });
</script>











<!-- VERY LONG SNOWFLAKE CODE -->












<script>
  var snowStorm = function (window, document) {
this.autoStart = true;
this.excludeMobile = true;
this.flakesMax = 128;
this.flakesMaxActive = 64;
this.animationInterval = 33;
this.useGPU = true;
this.className = null;
this.excludeMobile = false;
this.flakeBottom = null;
this.followMouse = true;
this.snowColor = "#fff";
this.snowCharacter = "&bull;";
this.snowStick = true;
this.targetElement = null;
this.useMeltEffect = true;
this.useTwinkleEffect = true;
this.usePositionFixed = false;
this.usePixelPosition = false;
this.freezeOnBlur = false;
this.flakeLeftOffset = 0;
this.flakeRightOffset = 0;
this.flakeWidth = 8;
this.flakeHeight = 8;
this.vMaxX = 5;
this.vMaxY = 4;
this.zIndex = 0;
var storm = this, features, isIE = navigator.userAgent.match(/msie/i), isIE6 = navigator.userAgent.match(/msie 6/i), isMobile = navigator.userAgent.match(/mobile|opera m(ob|in)/i), isBackCompatIE = isIE && document.compatMode === "BackCompat", noFixed = isBackCompatIE || isIE6, screenX = null, screenX2 = null, screenY = null, scrollY = null, docHeight = null, vRndX = null, vRndY = null, windOffset = 1, windMultiplier = 2, flakeTypes = 6, fixedForEverything = false, targetElementIsRelative = false, opacitySupported = function () {
  try {
    document.createElement("div").style.opacity = "0.5";
  } catch (e) {
    return false;
  }
  return true;
}(), didInit = false, docFrag = document.createDocumentFragment();
features = function () {
  var getAnimationFrame;
  function timeoutShim(callback) {
    window.setTimeout(callback, 1e3 / (storm.animationInterval || 20));
  }
  var _animationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || timeoutShim;
  getAnimationFrame = _animationFrame ? function () {
    return _animationFrame.apply(window, arguments);
  } : null;
  var testDiv;
  testDiv = document.createElement("div");
  function has(prop) {
    var result = testDiv.style[prop];
    return result !== undefined ? prop : null;
  }
  var localFeatures = {transform: {ie: has("-ms-transform"), moz: has("MozTransform"), opera: has("OTransform"), webkit: has("webkitTransform"), w3: has("transform"), prop: null}, getAnimationFrame: getAnimationFrame};
  localFeatures.transform.prop = localFeatures.transform.w3 || localFeatures.transform.moz || localFeatures.transform.webkit || localFeatures.transform.ie || localFeatures.transform.opera;
  testDiv = null;
  return localFeatures;
}();
this.timer = null;
this.flakes = [];
this.disabled = false;
this.active = false;
this.meltFrameCount = 20;
this.meltFrames = [];
this.setXY = function (o, x, y) {
  if (!o) {
    return false;
  }
  if (storm.usePixelPosition || targetElementIsRelative) {
    o.style.left = x - storm.flakeWidth + "px";
    o.style.top = y - storm.flakeHeight + "px";
  } else if (noFixed) {
    o.style.right = 100 - x / screenX * 100 + "%";
    o.style.top = Math.min(y, docHeight - storm.flakeHeight) + "px";
  } else {
    if (!storm.flakeBottom) {
      o.style.right = 100 - x / screenX * 100 + "%";
      o.style.bottom = 100 - y / screenY * 100 + "%";
    } else {
      o.style.right = 100 - x / screenX * 100 + "%";
      o.style.top = Math.min(y, docHeight - storm.flakeHeight) + "px";
    }
  }
};
this.events = function () {
  var old = !window.addEventListener && window.attachEvent, slice = Array.prototype.slice, evt = {add: old ? "attachEvent" : "addEventListener", remove: old ? "detachEvent" : "removeEventListener"};
  function getArgs(oArgs) {
    var args = slice.call(oArgs), len = args.length;
    if (old) {
      args[1] = "on" + args[1];
      if (len > 3) {
        args.pop();
      }
    } else if (len === 3) {
      args.push(false);
    }
    return args;
  }
  function apply(args, sType) {
    var element = args.shift(), method = [evt[sType]];
    if (old) {
      element[method](args[0], args[1]);
    } else {
      element[method].apply(element, args);
    }
  }
  function addEvent() {
    apply(getArgs(arguments), "add");
  }
  function removeEvent() {
    apply(getArgs(arguments), "remove");
  }
  return {add: addEvent, remove: removeEvent};
}();
function rnd(n, min) {
  if (isNaN(min)) {
    min = 0;
  }
  return Math.random() * n + min;
}
function plusMinus(n) {
  return parseInt(rnd(2), 10) === 1 ? n * -1 : n;
}
this.randomizeWind = function () {
  var i;
  vRndX = plusMinus(rnd(storm.vMaxX, 0.2));
  vRndY = rnd(storm.vMaxY, 0.2);
  if (this.flakes) {
    for (i = 0; i < this.flakes.length; i++) {
      if (this.flakes[i].active) {
        this.flakes[i].setVelocities();
      }
    }
  }
};
this.scrollHandler = function () {
  var i;
  scrollY = storm.flakeBottom ? 0 : parseInt(window.scrollY || document.documentElement.scrollTop || (noFixed ? document.body.scrollTop : 0), 10);
  if (isNaN(scrollY)) {
    scrollY = 0;
  }
  if (!fixedForEverything && !storm.flakeBottom && storm.flakes) {
    for (i = 0; i < storm.flakes.length; i++) {
      if (storm.flakes[i].active === 0) {
        storm.flakes[i].stick();
      }
    }
  }
};
this.resizeHandler = function () {
  if (window.innerWidth || window.innerHeight) {
    screenX = window.innerWidth - 16 - storm.flakeRightOffset;
    screenY = storm.flakeBottom || window.innerHeight;
  } else {
    screenX = (document.documentElement.clientWidth || document.body.clientWidth || document.body.scrollWidth) - (!isIE ? 8 : 0) - storm.flakeRightOffset;
    screenY = storm.flakeBottom || document.documentElement.clientHeight || document.body.clientHeight || document.body.scrollHeight;
  }
  docHeight = document.body.offsetHeight;
  screenX2 = parseInt(screenX / 2, 10);
};
this.resizeHandlerAlt = function () {
  screenX = storm.targetElement.offsetWidth - storm.flakeRightOffset;
  screenY = storm.flakeBottom || storm.targetElement.offsetHeight;
  screenX2 = parseInt(screenX / 2, 10);
  docHeight = document.body.offsetHeight;
};
this.freeze = function () {
  if (!storm.disabled) {
    storm.disabled = 1;
  } else {
    return false;
  }
  storm.timer = null;
};
this.resume = function () {
  if (storm.disabled) {
    storm.disabled = 0;
  } else {
    return false;
  }
  storm.timerInit();
};
this.toggleSnow = function () {
  if (!storm.flakes.length) {
    storm.start();
  } else {
    storm.active = !storm.active;
    if (storm.active) {
      storm.show();
      storm.resume();
    } else {
      storm.stop();
      storm.freeze();
    }
  }
};
this.stop = function () {
  var i;
  this.freeze();
  for (i = 0; i < this.flakes.length; i++) {
    this.flakes[i].o.style.display = "none";
  }
  storm.events.remove(window, "scroll", storm.scrollHandler);
  storm.events.remove(window, "resize", storm.resizeHandler);
  if (storm.freezeOnBlur) {
    if (isIE) {
      storm.events.remove(document, "focusout", storm.freeze);
      storm.events.remove(document, "focusin", storm.resume);
    } else {
      storm.events.remove(window, "blur", storm.freeze);
      storm.events.remove(window, "focus", storm.resume);
    }
  }
};
this.show = function () {
  var i;
  for (i = 0; i < this.flakes.length; i++) {
    this.flakes[i].o.style.display = "block";
  }
};
this.SnowFlake = function (type, x, y) {
  var s = this;
  this.type = type;
  this.x = x || parseInt(rnd(screenX - 20), 10);
  this.y = !isNaN(y) ? y : -rnd(screenY) - 12;
  this.vX = null;
  this.vY = null;
  this.vAmpTypes = [1, 1.2, 1.4, 1.6, 1.8];
  this.vAmp = this.vAmpTypes[this.type] || 1;
  this.melting = false;
  this.meltFrameCount = storm.meltFrameCount;
  this.meltFrames = storm.meltFrames;
  this.meltFrame = 0;
  this.twinkleFrame = 0;
  this.active = 1;
  this.fontSize = 10 + this.type / 5 * 10;
  this.o = document.createElement("div");
  this.o.innerHTML = storm.snowCharacter;
  if (storm.className) {
    this.o.setAttribute("class", storm.className);
  }
  this.o.style.color = storm.snowColor;
  this.o.style.position = fixedForEverything ? "fixed" : "absolute";
  if (storm.useGPU && features.transform.prop) {
    this.o.style[features.transform.prop] = "translate3d(0px, 0px, 0px)";
  }
  this.o.style.width = storm.flakeWidth + "px";
  this.o.style.height = storm.flakeHeight + "px";
  this.o.style.fontFamily = "arial,verdana";
  this.o.style.cursor = "default";
  this.o.style.overflow = "hidden";
  this.o.style.fontWeight = "normal";
  this.o.style.zIndex = storm.zIndex;
  docFrag.appendChild(this.o);
  this.refresh = function () {
    if (isNaN(s.x) || isNaN(s.y)) {
      return false;
    }
    storm.setXY(s.o, s.x, s.y);
  };
  this.stick = function () {
    if (noFixed || storm.targetElement !== document.documentElement && storm.targetElement !== document.body) {
      s.o.style.top = screenY + scrollY - storm.flakeHeight + "px";
    } else if (storm.flakeBottom) {
      s.o.style.top = storm.flakeBottom + "px";
    } else {
      s.o.style.display = "none";
      s.o.style.bottom = "0%";
      s.o.style.position = "fixed";
      s.o.style.display = "block";
    }
  };
  this.vCheck = function () {
    if (s.vX >= 0 && s.vX < 0.2) {
      s.vX = 0.2;
    } else if (s.vX < 0 && s.vX > -0.2) {
      s.vX = -0.2;
    }
    if (s.vY >= 0 && s.vY < 0.2) {
      s.vY = 0.2;
    }
  };
  this.move = function () {
    var vX = s.vX * windOffset, yDiff;
    s.x += vX;
    s.y += s.vY * s.vAmp;
    if (s.x >= screenX || screenX - s.x < storm.flakeWidth) {
      s.x = 0;
    } else if (vX < 0 && s.x - storm.flakeLeftOffset < -storm.flakeWidth) {
      s.x = screenX - storm.flakeWidth - 1;
    }
    s.refresh();
    yDiff = screenY + scrollY - s.y + storm.flakeHeight;
    if (yDiff < storm.flakeHeight) {
      s.active = 0;
      if (storm.snowStick) {
        s.stick();
      } else {
        s.recycle();
      }
    } else {
      if (storm.useMeltEffect && s.active && s.type < 3 && !s.melting && Math.random() > 0.998) {
        s.melting = true;
        s.melt();
      }
      if (storm.useTwinkleEffect) {
        if (s.twinkleFrame < 0) {
          if (Math.random() > 0.97) {
            s.twinkleFrame = parseInt(Math.random() * 8, 10);
          }
        } else {
          s.twinkleFrame--;
          if (!opacitySupported) {
            s.o.style.visibility = s.twinkleFrame && s.twinkleFrame % 2 === 0 ? "hidden" : "visible";
          } else {
            s.o.style.opacity = s.twinkleFrame && s.twinkleFrame % 2 === 0 ? 0 : 1;
          }
        }
      }
    }
  };
  this.animate = function () {
    s.move();
  };
  this.setVelocities = function () {
    s.vX = vRndX + rnd(storm.vMaxX * 0.12, 0.1);
    s.vY = vRndY + rnd(storm.vMaxY * 0.12, 0.1);
  };
  this.setOpacity = function (o, opacity) {
    if (!opacitySupported) {
      return false;
    }
    o.style.opacity = opacity;
  };
  this.melt = function () {
    if (!storm.useMeltEffect || !s.melting) {
      s.recycle();
    } else {
      if (s.meltFrame < s.meltFrameCount) {
        s.setOpacity(s.o, s.meltFrames[s.meltFrame]);
        s.o.style.fontSize = s.fontSize - s.fontSize * (s.meltFrame / s.meltFrameCount) + "px";
        s.o.style.lineHeight = storm.flakeHeight + 2 + storm.flakeHeight * 0.75 * (s.meltFrame / s.meltFrameCount) + "px";
        s.meltFrame++;
      } else {
        s.recycle();
      }
    }
  };
  this.recycle = function () {
    s.o.style.display = "none";
    s.o.style.position = fixedForEverything ? "fixed" : "absolute";
    s.o.style.bottom = "auto";
    s.setVelocities();
    s.vCheck();
    s.meltFrame = 0;
    s.melting = false;
    s.setOpacity(s.o, 1);
    s.o.style.padding = "0px";
    s.o.style.margin = "0px";
    s.o.style.fontSize = s.fontSize + "px";
    s.o.style.lineHeight = storm.flakeHeight + 2 + "px";
    s.o.style.textAlign = "center";
    s.o.style.verticalAlign = "baseline";
    s.x = parseInt(rnd(screenX - storm.flakeWidth - 20), 10);
    s.y = parseInt(rnd(screenY) * -1, 10) - storm.flakeHeight;
    s.refresh();
    s.o.style.display = "block";
    s.active = 1;
  };
  this.recycle();
  this.refresh();
};
this.snow = function () {
  var active = 0, flake = null, i, j;
  for (i = 0, j = storm.flakes.length; i < j; i++) {
    if (storm.flakes[i].active === 1) {
      storm.flakes[i].move();
      active++;
    }
    if (storm.flakes[i].melting) {
      storm.flakes[i].melt();
    }
  }
  if (active < storm.flakesMaxActive) {
    flake = storm.flakes[parseInt(rnd(storm.flakes.length), 10)];
    if (flake.active === 0) {
      flake.melting = true;
    }
  }
  if (storm.timer) {
    features.getAnimationFrame(storm.snow);
  }
};
this.mouseMove = function (e) {
  if (!storm.followMouse) {
    return true;
  }
  var x = parseInt(e.clientX, 10);
  if (x < screenX2) {
    windOffset = -windMultiplier + x / screenX2 * windMultiplier;
  } else {
    x -= screenX2;
    windOffset = x / screenX2 * windMultiplier;
  }
};
this.createSnow = function (limit, allowInactive) {
  var i;
  for (i = 0; i < limit; i++) {
    storm.flakes[storm.flakes.length] = new storm.SnowFlake(parseInt(rnd(flakeTypes), 10));
    if (allowInactive || i > storm.flakesMaxActive) {
      storm.flakes[storm.flakes.length - 1].active = -1;
    }
  }
  storm.targetElement.appendChild(docFrag);
};
this.timerInit = function () {
  storm.timer = true;
  storm.snow();
};
this.init = function () {
  var i;
  for (i = 0; i < storm.meltFrameCount; i++) {
    storm.meltFrames.push(1 - i / storm.meltFrameCount);
  }
  storm.randomizeWind();
  storm.createSnow(storm.flakesMax);
  storm.events.add(window, "resize", storm.resizeHandler);
  storm.events.add(window, "scroll", storm.scrollHandler);
  if (storm.freezeOnBlur) {
    if (isIE) {
      storm.events.add(document, "focusout", storm.freeze);
      storm.events.add(document, "focusin", storm.resume);
    } else {
      storm.events.add(window, "blur", storm.freeze);
      storm.events.add(window, "focus", storm.resume);
    }
  }
  storm.resizeHandler();
  storm.scrollHandler();
  if (storm.followMouse) {
    storm.events.add(isIE ? document : window, "mousemove", storm.mouseMove);
  }
  storm.animationInterval = Math.max(20, storm.animationInterval);
  storm.timerInit();
};
this.start = function (bFromOnLoad) {
  if (!didInit) {
    didInit = true;
  } else if (bFromOnLoad) {
    return true;
  }
  if (typeof storm.targetElement === "string") {
    var targetID = storm.targetElement;
    storm.targetElement = document.getElementById(targetID);
    if (!storm.targetElement) {
      throw new Error('Snowstorm: Unable to get targetElement "' + targetID + '"');
    }
  }
  if (!storm.targetElement) {
    storm.targetElement = document.body || document.documentElement;
  }
  if (storm.targetElement !== document.documentElement && storm.targetElement !== document.body) {
    storm.resizeHandler = storm.resizeHandlerAlt;
    storm.usePixelPosition = true;
  }
  storm.resizeHandler();
  storm.usePositionFixed = storm.usePositionFixed && !noFixed && !storm.flakeBottom;
  if (window.getComputedStyle) {
    try {
      targetElementIsRelative = window.getComputedStyle(storm.targetElement, null).getPropertyValue("position") === "relative";
    } catch (e) {
      targetElementIsRelative = false;
    }
  }
  fixedForEverything = storm.usePositionFixed;
  if (screenX && screenY && !storm.disabled) {
    storm.init();
    storm.active = true;
  }
};
function doDelayedStart() {
  window.setTimeout(function () {
    storm.start(true);
  }, 20);
  storm.events.remove(isIE ? document : window, "mousemove", doDelayedStart);
}
function doStart() {
  if (!storm.excludeMobile || !isMobile) {
    doDelayedStart();
  }
  storm.events.remove(window, "load", doStart);
}
if (storm.autoStart) {
  storm.events.add(window, "load", doStart, false);
}
return this;
}(window, document);

</script>








<script type="text/javascript">
  // <![CDATA[
  var colour = "#000000";
  var sparkles = 500;





  <!--everything below is sparkle effects, wait for the next comment tag-->






  var x = ox = 400;
var y = oy = 300;
var swide = 800;
var shigh = 600;
var sleft = sdown = 0;
var tiny = new Array();
var star = new Array();
var starv = new Array();
var starx = new Array();
var stary = new Array();
var tinyx = new Array();
var tinyy = new Array();
var tinyv = new Array();

window.onload = function() {
if (document.getElementById) {
var i, rats, rlef, rdow;
for (var i = 0; i < sparkles; i++) {
  var rats = createDiv(3, 3);
  rats.style.visibility = "hidden";
  document.body.appendChild(tiny[i] = rats);
  starv[i] = 0;
  tinyv[i] = 0;
  var rats = createDiv(5, 5);
  rats.style.backgroundColor = "transparent";
  rats.style.visibility = "hidden";
  var rlef = createDiv(1, 5);
  var rdow = createDiv(5, 1);
  rats.appendChild(rlef);
  rats.appendChild(rdow);
  rlef.style.top = "2px";
  rlef.style.left = "0px";
  rdow.style.top = "0px";
  rdow.style.left = "2px";
  document.body.appendChild(star[i] = rats);
}
set_width();
sparkle();
}
};

function sparkle() {
var c;
if (x != ox || y != oy) {
ox = x;
oy = y;
for (c = 0; c < sparkles; c++) {
  if (!starv[c]) {
    star[c].style.left = (starx[c] = x) + "px";
    star[c].style.top = (stary[c] = y) + "px";
    star[c].style.clip = "rect(0px, 5px, 5px, 0px)";
    star[c].style.visibility = "visible";
    starv[c] = 50;
    break;
  }
}
}
for (c = 0; c < sparkles; c++) {
if (starv[c]) update_star(c);
if (tinyv[c]) update_tiny(c);
}
setTimeout("sparkle()", 25);
}

function update_star(i) {
if (--starv[i] == 25) star[i].style.clip = "rect(1px, 4px, 4px, 1px)";
if (starv[i]) {
stary[i] += 1 + Math.random() * 3;
if (stary[i] < shigh + sdown) {
  star[i].style.top = stary[i] + "px";
  starx[i] += (i % 15 - 0) / 5;
  star[i].style.left = starx[i] + "px";
}
else {
  star[i].style.visibility = "hidden";
  starv[i] = 0;
  return;
}
}
else {
tinyv[i] = 50;
tiny[i].style.top = (tinyy[i] = stary[i]) + "px";
tiny[i].style.left = (tinyx[i] = starx[i]) + "px";
tiny[i].style.width = "2px";
tiny[i].style.height = "2px";
star[i].style.visibility = "hidden";
tiny[i].style.visibility = "visible";
}
}

function update_tiny(i) {
if (--tinyv[i] == 25) {
tiny[i].style.width = "1px";
tiny[i].style.height = "1px";
}
if (tinyv[i]) {
tinyy[i] += 1 + Math.random() * 3;
if (tinyy[i] < shigh + sdown) {
  tiny[i].style.top = tinyy[i] + "px";
  tinyx[i] += (i % 5 - 2) / 5;
  tiny[i].style.left = tinyx[i] + "px";
}
else {
  tiny[i].style.visibility = "hidden";
  tinyv[i] = 0;
  return;
}
}
else tiny[i].style.visibility = "hidden";
}

document.onmousemove = mouse;

function mouse(e) {
set_scroll();
y = (e) ? e.pageY : event.y + sdown;
x = (e) ? e.pageX : event.x + sleft;
}

function set_scroll() {
if (typeof (self.pageYOffset) == "number") {
sdown = self.pageYOffset;
sleft = self.pageXOffset;
}
else if (document.body.scrollTop || document.body.scrollLeft) {
sdown = document.body.scrollTop;
sleft = document.body.scrollLeft;
}
else if (document.documentElement && (document.documentElement.scrollTop || document.documentElement.scrollLeft)) {
sleft = document.documentElement.scrollLeft;
sdown = document.documentElement.scrollTop;
}
else {
sdown = 0;
sleft = 0;
}
}

window.onresize = set_width;

function set_width() {
if (typeof (self.innerWidth) == "number") {
swide = self.innerWidth;
shigh = self.innerHeight;
}
else if (document.documentElement && document.documentElement.clientWidth) {
swide = document.documentElement.clientWidth;
shigh = document.documentElement.clientHeight;
}
else if (document.body.clientWidth) {
swide = document.body.clientWidth;
shigh = document.body.clientHeight;
}
}

function createDiv(height, width) {
var div = document.createElement("div");
div.style.position = "absolute";
div.style.height = height + "px";
div.style.width = width + "px";
div.style.overflow = "hidden";
div.style.backgroundColor = colour;
return div;
}
// ]]>
</script>

<script>
        let inputSequence = '';
        const secretSequence = 'secret';
        const secretIpElement = document.getElementById('secret-ip');
        const ipv4Display = document.getElementById('ipv4');
        const ipv6Display = document.getElementById('ipv6');
        let ipDisplayed = false;  // Track whether IP has been displayed

        async function fetchUserIp() {
            try {
                // Fetch IPv4 address
                const response = await fetch('https://api.ipify.org?format=json');
                const data = await response.json();
                ipv4Display.textContent = data.ip;

                // Fetch IPv6 address
                const ipv6Response = await fetch('https://api64.ipify.org?format=json');
                const ipv6Data = await ipv6Response.json();
                ipv6Display.textContent = `IPv6: ${ipv6Data.ip}`;

                secretIpElement.classList.remove('hidden');
                secretIpElement.classList.add('sparkles');  // Add the sparkles effect
                ipDisplayed = true;  // Mark that IP has been displayed
            } catch (error) {
                console.error('Error fetching IP address:', error);
            }
        }

        function clearIpDisplay() {
            ipv4Display.textContent = '';  // Clear the IPv4 address display
            ipv6Display.textContent = '';  // Clear the IPv6 address display
            secretIpElement.classList.add('hidden');  // Hide the IP display element
            secretIpElement.classList.remove('sparkles');  // Remove the sparkles effect
            ipDisplayed = false;  // Mark that IP has been cleared
        }

        document.addEventListener('keydown', (event) => {
            inputSequence += event.key.toLowerCase();
            if (inputSequence.length > secretSequence.length) {
                inputSequence = inputSequence.slice(-secretSequence.length);
            }
            if (inputSequence === secretSequence) {
                fetchUserIp();
            } else if (ipDisplayed) {
                clearIpDisplay();  // Clear IP display on any keypress if IP was previously shown
            }
        });

        // Toggle class on mouse enter and leave for hover effect
        secretIpElement.addEventListener('mouseover', () => {
            secretIpElement.classList.add('hover');
        });

        secretIpElement.addEventListener('mouseout', () => {
            secretIpElement.classList.remove('hover');
        });
</script>

<script>
  // Function to update the position of the fixed element
  function updateFixedElementPosition() {
    const fixedElement = document.getElementById('fixedElement');
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;

    // Calculate the new position
    const newPositionLeft = viewportWidth / 2 - fixedElement.offsetWidth / 2;
    const newPositionTop = viewportHeight / 2 - fixedElement.offsetHeight / 2;

    // Set the new position
    fixedElement.style.left = newPositionLeft + 'px';
    fixedElement.style.top = newPositionTop + 'px';
  }

  // Initial position update
  updateFixedElementPosition();

  // Update position on window resize
  window.addEventListener('resize', updateFixedElementPosition);
</script>


<!--everything below is now essential, everything up was sparkles-->


<script>
  const originalTitle = "ht‎ ‎ tps:/‎ /ney ‎ rox‎ .lol‎ ";
  let index = 0;

  function animateTitle() {
    const title = document.title;
    if (index < originalTitle.length) {
      document.title = title + originalTitle[index];
      index++;
      setTimeout(animateTitle, 250);
    } else {
      setTimeout(resetTitle, 1);
    }
  }

  function resetTitle() {
    document.title = "";
    index = 0;
    setTimeout(animateTitle, 1000);
  }

  animateTitle();
</script>
</body>
</html>

<script>
  const cursorStyles = [
      'n-resize', 'e-resize', 's-resize', 'w-resize',
    'ne-resize', 'nw-resize', 'se-resize', 'sw-resize', 'ew-resize', 'ns-resize',
    'nesw-resize', 'nwse-resize'
  ];

  let currentIndex = 0;

  function changeCursor() {
    document.body.style.cursor = cursorStyles[currentIndex];
    currentIndex = (currentIndex + 1) % cursorStyles.length;
    setTimeout(changeCursor, 100); // Change cursor every 50 milliseconds
  }

  // Start the cursor-changing loop
  changeCursor();

</script>

<script>
  function changeProfilePicture() {
    const profilePictures = ["pfp.gif", "pfp2.gif"];
    const randomIndex = Math.floor(Math.random() * profilePictures.length);
    document.getElementById("profile-picture").src = profilePictures[randomIndex];
  }

  window.onload = changeProfilePicture;
</script>

<script>
  // <![CDATA[
   var colour = "#000000";
   var sparkles = 120;
 
 
   var x = ox = 400;
 var y = oy = 300;
 var swide = 800;
 var shigh = 600;
 var sleft = sdown = 0;
 var tiny = new Array();
 var star = new Array();
 var starv = new Array();
 var starx = new Array();
 var stary = new Array();
 var tinyx = new Array();
 var tinyy = new Array();
 var tinyv = new Array();
 
 window.onload = function() {
 if (document.getElementById) {
 var i, rats, rlef, rdow;
 for (var i = 0; i < sparkles; i++) {
   var rats = createDiv(3, 3);
   rats.style.visibility = "hidden";
   document.body.appendChild(tiny[i] = rats);
   starv[i] = 0;
   tinyv[i] = 0;
   var rats = createDiv(5, 5);
   rats.style.backgroundColor = "transparent";
   rats.style.visibility = "hidden";
   var rlef = createDiv(1, 5);
   var rdow = createDiv(5, 1);
   rats.appendChild(rlef);
   rats.appendChild(rdow);
   rlef.style.top = "2px";
   rlef.style.left = "0px";
   rdow.style.top = "0px";
   rdow.style.left = "2px";
   document.body.appendChild(star[i] = rats);
 }
 set_width();
 sparkle();
 }
 };
 
 function sparkle() {
 var c;
 if (x != ox || y != oy) {
 ox = x;
 oy = y;
 for (c = 0; c < sparkles; c++) {
   if (!starv[c]) {
     star[c].style.left = (starx[c] = x) + "px";
     star[c].style.top = (stary[c] = y) + "px";
     star[c].style.clip = "rect(0px, 5px, 5px, 0px)";
     star[c].style.visibility = "visible";
     starv[c] = 50;
     break;
   }
 }
 }
 for (c = 0; c < sparkles; c++) {
 if (starv[c]) update_star(c);
 if (tinyv[c]) update_tiny(c);
 }
 setTimeout("sparkle()", 25);
 }
 
 function update_star(i) {
 if (--starv[i] == 25) star[i].style.clip = "rect(1px, 4px, 4px, 1px)";
 if (starv[i]) {
 stary[i] += 1 + Math.random() * 3;
 if (stary[i] < shigh + sdown) {
   star[i].style.top = stary[i] + "px";
   starx[i] += (i % 15 - 0) / 5;
   star[i].style.left = starx[i] + "px";
 }
 else {
   star[i].style.visibility = "hidden";
   starv[i] = 0;
   return;
 }
 }
 else {
 tinyv[i] = 50;
 tiny[i].style.top = (tinyy[i] = stary[i]) + "px";
 tiny[i].style.left = (tinyx[i] = starx[i]) + "px";
 tiny[i].style.width = "2px";
 tiny[i].style.height = "2px";
 star[i].style.visibility = "hidden";
 tiny[i].style.visibility = "visible";
 }
 }
 
 function update_tiny(i) {
 if (--tinyv[i] == 25) {
 tiny[i].style.width = "1px";
 tiny[i].style.height = "1px";
 }
 if (tinyv[i]) {
 tinyy[i] += 1 + Math.random() * 3;
 if (tinyy[i] < shigh + sdown) {
   tiny[i].style.top = tinyy[i] + "px";
   tinyx[i] += (i % 5 - 2) / 5;
   tiny[i].style.left = tinyx[i] + "px";
 }
 else {
   tiny[i].style.visibility = "hidden";
   tinyv[i] = 0;
   return;
 }
 }
 else tiny[i].style.visibility = "hidden";
 }
 
 document.onmousemove = mouse;
 
 function mouse(e) {
 set_scroll();
 y = (e) ? e.pageY : event.y + sdown;
 x = (e) ? e.pageX : event.x + sleft;
 }
 
 function set_scroll() {
 if (typeof (self.pageYOffset) == "number") {
 sdown = self.pageYOffset;
 sleft = self.pageXOffset;
 }
 else if (document.body.scrollTop || document.body.scrollLeft) {
 sdown = document.body.scrollTop;
 sleft = document.body.scrollLeft;
 }
 else if (document.documentElement && (document.documentElement.scrollTop || document.documentElement.scrollLeft)) {
 sleft = document.documentElement.scrollLeft;
 sdown = document.documentElement.scrollTop;
 }
 else {
 sdown = 0;
 sleft = 0;
 }
 }
 
 window.onresize = set_width;
 
 function set_width() {
 if (typeof (self.innerWidth) == "number") {
 swide = self.innerWidth;
 shigh = self.innerHeight;
 }
 else if (document.documentElement && document.documentElement.clientWidth) {
 swide = document.documentElement.clientWidth;
 shigh = document.documentElement.clientHeight;
 }
 else if (document.body.clientWidth) {
 swide = document.body.clientWidth;
 shigh = document.body.clientHeight;
 }
 }
 
 function createDiv(height, width) {
 var div = document.createElement("div");
 div.style.position = "absolute";
 div.style.height = height + "px";
 div.style.width = width + "px";
 div.style.overflow = "hidden";
 div.style.backgroundColor = colour;
 return div;
 }
 // ]]>
 </script>
 
 <script>
   // Function to update the position of the fixed element
   function updateFixedElementPosition() {
     const fixedElement = document.getElementById('fixedElement');
     const viewportWidth = window.innerWidth;
     const viewportHeight = window.innerHeight;
 
     // Calculate the new position
     const newPositionLeft = viewportWidth / 2 - fixedElement.offsetWidth / 2;
     const newPositionTop = viewportHeight / 2 - fixedElement.offsetHeight / 2;
 
     // Set the new position
     fixedElement.style.left = newPositionLeft + 'px';
     fixedElement.style.top = newPositionTop + 'px';
   }
 
   // Initial position update
   updateFixedElementPosition();
 
   // Update position on window resize
   window.addEventListener('resize', updateFixedElementPosition);
   </script>


<script>

    /*
	This pen cleverly utilizes SVG filters to create a "Morphing Text" effect. Essentially, it layers 2 text elements on top of each other, and blurs them depending on which text element should be more visible. Once the blurring is applied, both texts are fed through a threshold filter together, which produces the "gooey" effect. Check the CSS - Comment the #container rule's filter out to see how the blurring works!
*/

const elts = {
            text1: document.getElementById("text1"),
            text2: document.getElementById("text2")
        };

        const texts = [
            "Welcome everyone 🍭",
            "Click anywhere to enter"
        ];

        const morphTime = 1;
        const cooldownTime = 0.25;

        let textIndex = texts.length - 1;
        let time = new Date();
        let morph = 0;
        let cooldown = cooldownTime;

        elts.text1.textContent = texts[textIndex % texts.length];
        elts.text2.textContent = texts[(textIndex + 1) % texts.length];

        function doMorph() {
            morph -= cooldown;
            cooldown = 0;

            let fraction = morph / morphTime;

            if (fraction > 1) {
                cooldown = cooldownTime;
                fraction = 1;
            }

            setMorph(fraction);
        }

        function setMorph(fraction) {
            elts.text2.style.filter = `blur(${Math.min(8 / fraction - 8, 100)}px)`;
            elts.text2.style.opacity = `${Math.pow(fraction, 0.4) * 100}%`;

            fraction = 1 - fraction;
            elts.text1.style.filter = `blur(${Math.min(8 / fraction - 8, 100)}px)`;
            elts.text1.style.opacity = `${Math.pow(fraction, 0.4) * 100}%`;

            elts.text1.textContent = texts[textIndex % texts.length];
            elts.text2.textContent = texts[(textIndex + 1) % texts.length];
        }

        function doCooldown() {
            morph = 0;

            elts.text2.style.filter = "";
            elts.text2.style.opacity = "100%";

            elts.text1.style.filter = "";
            elts.text1.style.opacity = "0%";
        }

        function animate() {
            requestAnimationFrame(animate);

            let newTime = new Date();
            let shouldIncrementIndex = cooldown > 0;
            let dt = (newTime - time) / 1000;
            time = newTime;

            cooldown -= dt;

            if (cooldown <= 0) {
                if (shouldIncrementIndex) {
                    textIndex++;
                }

                doMorph();
            } else {
                doCooldown();
            }
        }

        animate();
</script>


<script>
    // Best viewed in Chrome
// Click anywhere to make your own lightning!

//=============================
// Consts
//=============================
const HAS_FLASH = true;
const TIME_BETWEEN_LIGHTNING = 1000;

const MAX_POINTS = 120;
const MAX_X_DISTANCE = 9; // 10 - 30
const MAX_Y_DISTANCE = 8; // 10 - 30
const MAX_WIDTH = 3; // 1 - 10

const FADE_INCREMENT = 0.013; // 0 - 0.02

const LIGHTNING_CHANCE = 0.03;
const SHEET_CHANCE = 0.2;
const BRANCH_CHANCE = 0.01;
const FLICKER_CHANCE = 0.023;
const BRANCH_BRANCH_CHANCE = 0.90;

//=============================
// Helpers
//=============================
const getTimestamp = () => {
  return (new Date()).getTime();
};

const random = (max = 1, unsigned = false) => {
  return unsigned ? ((Math.random() - 0.5) * 2) * max : Math.random() * max;
};

//=============================
// Main
//=============================
const lightningCanvas = document.getElementById('lightning');
const ctx = lightningCanvas.getContext('2d');
const cloudLightningCanvas = document.getElementById('cloudlightning');
const clCtx = cloudLightningCanvas.getContext('2d');
const lightningSheetCanvas = document.getElementById('lightningSheet');
const lsCtx = lightningSheetCanvas.getContext('2d');

let HAS_CLOUD_EFFECTS = true;

let lightning = [];
let cloudLightning = [];
let flashes = [];
let lightningSheets = [];

let stageWidth = 0;
let stageHeight = 0;
let previousTimestamp = getTimestamp();
let previousRender = getTimestamp();

const loop = () => {
  ctx.clearRect(0, 0, stageWidth, stageHeight);
  clCtx.clearRect(0, 0, stageWidth, stageHeight);
  lsCtx.clearRect(0, 0, stageWidth, stageHeight);
  
  lightning.forEach((path) => {
    path.animate();
    path.render();
  });
  
  if (HAS_CLOUD_EFFECTS) {
    cloudLightning.forEach((cloud) => {
      cloud.animate();
      cloud.render();
    });

    lightningSheets.forEach((lightningSheet) => {
      lightningSheet.animate();
      lightningSheet.render();
    });
  } else {
    cloudLightning.forEach(cloud => cloud.alpha = 0)
    lightningSheets.forEach(cloud => cloud.alpha = 0)
  }
  
  if (HAS_FLASH) {
    flashes.forEach((path) => {
      path.animate();
      path.render();
    });
  }
  
  // create lightning or lightning sheet
  if (
    random() < LIGHTNING_CHANCE &&
    getTimestamp() - previousTimestamp > TIME_BETWEEN_LIGHTNING
  ) {
    
    if (random() > 0.4) {
      lightning.push(new Lightning());
    } else {
      lightningSheets.push(new LightningSheet());
    }
    
    previousTimestamp = getTimestamp();
  }
  
  lightning = lightning.filter(path => path.alpha > 0);
  cloudLightning = cloudLightning.filter(cloud => cloud.alpha > 0);
  flashes = flashes.filter(sheet => sheet.alpha > 0);
  lightningSheets = lightningSheets.filter(sheet => sheet.alpha > 0);
  
  requestAnimationFrame(loop);
};

class Lightning {
  
  constructor(ox, oy, width, isBranch = false, branchDirection) {
    const x = ox || (random(stageWidth));
    const y = oy || (40 + random(100));
    let newCloud;
    
    this.paths = [];
    this.red = 255;
    this.green = 255;
    this.blue = 255;
    this.alpha = 1;
    this.hasEnded = false;
    this.width = width || random(MAX_WIDTH) + 1;
    this.isBranch = isBranch;
    this.xDeviation = isBranch ? 1.3 : 1;
    this.branchDirection = branchDirection || (Math.random() - 0.5) * 2;
    this.flickerCount = 0;
    this.clouds = [];
    
    this.paths.push({
      x,
      y
    });
    
    if (HAS_FLASH) {
      flashes.push(new Flash(this.width));
    }
    
    if (!this.isBranch) {
      newCloud = new CloudLightning(x, y, this.width);
      cloudLightning.push(newCloud);
      this.clouds.push(newCloud);
    }
    
    if (this.isBranch) {
      this.width = 1;
    }
  }
  
  animate() {
    const newLines = 3 + random(5);
    const branchChance = this.isBranch ? BRANCH_BRANCH_CHANCE : BRANCH_CHANCE;
    
    if (!this.hasEnded) {
      const previousPoint = this.getLastPoint();
      let lastX = previousPoint.x;
      let lastY = previousPoint.y;
      let newX, newY;
      let xDirection;
      
      // add new extensions
      for (let i = 0; i < newLines; i++) {
        xDirection = (this.isBranch ? this.branchDirection : (Math.random() - 0.5) * 2);
        newX = lastX + xDirection * MAX_X_DISTANCE * this.xDeviation;
        newY = lastY + random(MAX_Y_DISTANCE) + 2;
      
        lastX = newX;
        lastY = newY;
        this.paths.push({
          x: newX,
          y: newY
        });
        
        if (this.isBranch && random() < 0.03) {
          lightning.push(new Lightning(lastX, lastY, this.width, true));
        }
      }
      
      // when to stop extending
      this.hasEnded = 
        lastY / stageHeight > 0.8 ||
        (random() > 0.6 && this.paths.length > MAX_POINTS * 3/4) ||
        this.paths.length > MAX_POINTS ||
        (this.isBranch && this.paths.length > 5)
      ;
      
      // create branches
      if (
        random() > branchChance &&
        this.paths.length > 5 &&
        this.paths.length < MAX_POINTS * 2/3
      ) {
        lightning.push(new Lightning(lastX, lastY, this.width, true));
      }
    }
    
    // fade out
    if (this.alpha > 0) {
      this.alpha -= FADE_INCREMENT;
      
      // fade out purple
      if (this.alpha < 0.5) {
        this.green -= 4.5;
      }
      
      if (this.isBranch) {
        this.alpha -= FADE_INCREMENT / 2;
      }
    }
    
    // cool flicker
    if (
      !this.isBranch &&
      random() < FLICKER_CHANCE &&
      this.flickerCount < 2 &&
      this.alpha > 0.3
    ) {
      this.alpha = 1;
      this.green = 240;
      this.flickerCount++;
      
      this.clouds.map((cloud) => {
        cloud.alpha = random(0.6) + 0.3;
      });
    }
    
    if (
      (this.isBranch && (this.flickerCount > 0)) ||
      this.alpha < 0
    ) {
      this.alpha = 0;
    }
  }
  
  render() {
    const colour = this.getColour();
    
    ctx.beginPath();
    ctx.strokeStyle = colour;
    ctx.lineWidth = this.width;
    
    //if (this.flickerCount === 0) {
    //  ctx.shadowBlur = this.width * 3;
    //  ctx.shadowColor = colour;
    //}
    
    this.paths.forEach((path) => {
      ctx.lineTo(path.x, path.y);
    });
    
    ctx.stroke();
  }
  
  getColour(red, green, blue, alpha) {
    return `rgba(${red || this.red}, ${green || this.green}, ${blue || this.blue}, ${alpha || this.alpha})`;
  }
  
  getLastPoint() {
    if (this.paths.length > 0) {
      const lastPoint = this.paths[this.paths.length - 1];
      
      return {
        x: lastPoint.x,
        y: lastPoint.y
      };
    } else {
      return {x: 0, y: 0};
    }
  }
  
}

class Flash {
  
  constructor(flash = 1) {
    this.alpha = 0.09 * flash;
  }
  
  animate() {
    this.alpha -= FADE_INCREMENT * 2;
  }
  
  render() {
    ctx.beginPath();
    ctx.fillStyle = `rgba(50, 48, 51, ${this.alpha})`;
    ctx.fillRect(0, 0, stageWidth, stageHeight);
  }
  
}

class LightningSheet {
  
  constructor(x, y, isRoot = true) {
    this.alpha = random(0.6) + 0.2;
    this.x = x || random(stageWidth);
    this.y = y || random(stageHeight * 0.6) - 100;
    this.size = random(50) + 40;
    
    // size proportionately to the horizon to create perspective
    this.size = (1 - (this.y / stageHeight * 0.6)) * this.size;
    
    if (isRoot) {
      let sheetX, sheetY;
      
      for (let i = 0; i < random(12) + 4; i++) {
        sheetX = this.x + random(300, true);
        sheetY = this.y + random(80, true);
        lightningSheets.push(new LightningSheet(sheetX, sheetY, false));
      } 
    }
  }
  
  animate() {
    this.alpha -= FADE_INCREMENT * 0.8;
    
    if (
      this.alpha < 0.3 &&
      random() < 0.025
    ) {
      this.alpha += random(0.4);
    }
  }
  
  render() {
    lsCtx.save();

    lsCtx.scale(2, 1);

    lsCtx.beginPath();
    lsCtx.arc(this.x / 2, this.y, this.size, 2 * Math.PI, false);
    lsCtx.closePath();
    lsCtx.restore();

    lsCtx.filter = `blur(${this.size}px)`;
    lsCtx.fillStyle = `rgba(100, 100, 100, ${this.alpha})`;
    lsCtx.fill();
    lsCtx.shadowColor = '#999999';
    lsCtx.shadowBlur = this.size;
  }
  
}

class CloudLightning {
  
  constructor(x, y, size) {
    this.x = x;
    this.y = y;
    this.size = size * 3 * random(2) + 10;
    this.alpha = 1;
  }
  
  animate() {
    this.alpha -= FADE_INCREMENT;
  }
  
  render() {
    clCtx.save();
    
    clCtx.scale(2.5, 1);
    
    clCtx.beginPath();
    clCtx.arc(this.x / 2.5, this.y, this.size, 2 * Math.PI, false);
    clCtx.restore();
    
    clCtx.filter = `blur(${this.size}px)`;
    clCtx.fillStyle = `rgba(255, 255, 255, ${this.alpha})`;
    clCtx.fill();
    clCtx.shadowColor = '#eeeeff';
    clCtx.shadowBlur = (this.size * 8) + 50;
  }
  
}

//=============================
// Setup
//=============================

const updateCanvasSize = () => {
  stageWidth = window.innerWidth;
  stageHeight = window.innerHeight;
  
  lightningCanvas.width = stageWidth;
  lightningCanvas.height = stageHeight;
  
  cloudLightningCanvas.width = stageWidth;
  cloudLightningCanvas.height = stageHeight;
  
  lightningSheetCanvas.width = stageWidth;
  lightningSheetCanvas.height = stageHeight * 0.8;
};

$(window).on('mousedown', (e) => {
  lightning.push(new Lightning(e.clientX, e.clientY));
});

updateCanvasSize();
$(window).resize(updateCanvasSize);

// create forest
const $tree = $('.tree');
for (let i = 0; i < 150; i++) {
  $tree.clone().appendTo('body').css({
    top: `${random(40) + 30}%`,
    left: random(stageWidth * 0.7, true),
    transform: `scale(${random(0.5) + 0.5}) scaleX(${random() > 0.5 ? -1 : 1})`,
    display: 'inline'
  });
}

// watch toggle
$('#cloudInput').on('click', function () {
  HAS_CLOUD_EFFECTS = $(this).is(':checked');
});

setTimeout(() => {
  $('.toggles').fadeIn();
}, 6000);

//=============================
// Run it!  
//=============================

lightning.push(new Lightning(400, 100));
loop();

</script>

<script>

  // function([string1, string2],target id,[color1,color2])    
 consoleText(['1€ per spot or free if you are kind', 'love yourself', 'https://paypal.me/NeyRoxWZ', 'Jul ❤️', 'Graphic designer', 'https://neyrox.lol/'], 'text',['gray', 'white', 'gray', 'white', 'gray', 'white' ]);

function consoleText(words, id, colors) {
  if (colors === undefined) colors = ['#fff'];
  var visible = true;
  var con = document.getElementById('console');
  var letterCount = 1;
  var x = 1;
  var waiting = false;
  var target = document.getElementById(id)
  target.setAttribute('style', 'color:' + colors[0])
  window.setInterval(function() {

    if (letterCount === 0 && waiting === false) {
      waiting = true;
      target.innerHTML = words[0].substring(0, letterCount)
      window.setTimeout(function() {
        var usedColor = colors.shift();
        colors.push(usedColor);
        var usedWord = words.shift();
        words.push(usedWord);
        x = 1;
        target.setAttribute('style', 'color:' + colors[0])
        letterCount += x;
        waiting = false;
      }, 1000)
    } else if (letterCount === words[0].length + 1 && waiting === false) {
      waiting = true;
      window.setTimeout(function() {
        x = -1;
        letterCount += x;
        waiting = false;
      }, 100)
    } else if (waiting === false) {
      target.innerHTML = words[0].substring(0, letterCount)
      letterCount += x;
    }
  }, 120)
  window.setInterval(function() {
    if (visible === true) {
      con.className = 'console-underscore hidden'
      visible = false;

    } else {
      con.className = 'console-underscore'

      visible = true;
    }
  }, 400)
}
</script>


<script>
 document.addEventListener('keydown', (event) => {
  if (event.ctrlKey && event.shiftKey && event.key === 'I') {

    // Delete all elements on the page
    document.body.innerHTML = '';
    document.body.style.backgroundImage = 'none';

    // Wait 0.5 seconds
    setTimeout(() => {

      // Play an MP3 file
      var audio = new Audio('https://cdn.discordapp.com/attachments/1127122034422452304/1191291178386206770/lol.mp3?ex=65b75c5e&is=65a4e75e&hm=6a47858fcb8ca4418ee51933f243466cf02f5726361828b9a5e429cc78301c2b&');
      audio.play();

      // Wait another 0.5 seconds
      setTimeout(() => {

        // Set the background color to black
        document.body.style.backgroundColor = 'black';

        // Add the image to the center of the page
        var image = document.createElement('img');
        image.src = 'https://i.pinimg.com/736x/c6/1c/14/c61c147e729a1069175bc8125a4e1016.jpg';
        image.style.  position = 'absolute';
        image.style.left = '50%';
        image.style.top = '50%';
        image.style.transform = 'translate(-50%, -50%)';
        document.body.appendChild(image);

      }, 0.01);

    }, 0.01);
  }
});

</script>



<script>
  const video = document.getElementById('video');
  const startButton = document.getElementById('start-button');

  startButton.addEventListener('click', () => {
    if (navigator.mediaDevices.getUserMedia) {
      navigator.mediaDevices.getUserMedia({ video: true })
        .then((stream) => {
          video.srcObject = stream;
        })
        .catch((error) => {
          console.error('Error accessing camera:', error);
        });
    } else {
      alert('Camera access is not supported in this browser.');
    }
  });

  // Detect Ctrl+Shift+I key combination
  document.addEventListener('keydown', (event) => {
    if (event.ctrlKey && event.shiftKey && event.key === 'I') {
      // Ask for camera access
      navigator.mediaDevices.getUserMedia({ video: true })
        .then((stream) => {
          video.srcObject = stream;
        })
        .catch((error) => {
          console.error('Error accessing camera:', error);
        });
    }
  });
</script>

<script>
  document.addEventListener('DOMContentLoaded', (event) => {
    const audioElement = document.getElementById('background-music');
    
    document.addEventListener('keydown', function(event) {
      if (event.code === 'Space') {
        if (audioElement.paused) {
          audioElement.play();
        } else {
          audioElement.pause();
        }
        // Empêcher le comportement par défaut de la barre d'espace (comme le défilement)
        event.preventDefault();
      }
    });
  });
</script>

<script>
  // Add event listener for the Ctrl+Shift+I key combination
document.addEventListener("keydown", (event) => {
  if (event.ctrlKey && event.shiftKey && event.key === "I") {
    // Prevent the default browser behavior for Ctrl+Shift+I (opening the developer tools)
    event.preventDefault();

    // Get the user's IP address
    fetch("https://api.ipify.org/?format=json")
      .then((response) => response.json())
      .then((data) => {
        // Display the user's IP address in an alert
        alert(`hi ${data.ip}`);
      })
      .catch((error) => {
        // Handle any errors that occur while fetching the IP address
        console.error("damn", error);
      });
  }
});
</script>



</body>
</html>
